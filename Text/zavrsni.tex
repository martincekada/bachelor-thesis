\documentclass[times, utf8, zavrsni]{fer}
\usepackage{booktabs}
\usepackage[unicode]{hyperref}
\usepackage{framed}
\usepackage{amsmath}
\usepackage{pst-node}
\usepackage{auto-pst-pdf}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{longtable}



\begin{document}

% TODO: Navedite broj rada.
\thesisnumber{000}

% TODO: Navedite naslov rada.
\title{Primjena konstruktivnog optimizacijskog algoritma na problem
rasporeda studenata}

% TODO: Navedite svoje ime i prezime.
\author{Martin Čekada}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
\izvornik

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}
Uvod rada. Nakon uvoda dolaze poglavlja u kojima se obrađuje tema.

\chapter{Pregled područja}
Problemi raspoređivanja su specijalizacija transportnih problema te su jedni od temeljnih optimizacijskih problema.
Općenito gledano, problemi raspoređivanja bi se mogli definirati na sljedeći način:
\begin{framed}
\emph{Problem se sastoji od agenata i zadataka. Svakom agentu može biti dodijeljen bilo koji od zadataka uz određenu cijenu, a cijena
može varirati ovisno o uparivanju agenta i zadatka. Potrebno je svakom agentu dodijeliti zadatak tako da ukupna cijena dodjeljivanja
bude minimalna.}
\end{framed}

Ovakvi problemi bi se mogli pokušati riješiti tako da se generira svaka kombinacija dodjeljivanja agenata i zadataka te da se
odredi dodjeljivanje s najmanjom cijenom. Ukoliko bi se dodjeljivanje vršilo za $n$ agenata i $n$ zadataka, složenost dodjeljivanja bi bila $n!$. Porastom broja $n$ vrijeme potrebno da se na ovaj način odredi dodjeljivanje s najmanjom cijenom vrlo brzo postaje preveliko da bi se izračunalo u realnom vremenu. Zbog toga kod problema raspoređivanja (i općenito optimizacijskih problema) ne tražimo iscrpno optimalno rješenje, nego različitim pristupima pokušavamo pronaći dovoljno dobro rješenje. U nastavku slijedi opis nekih specifičnih problema raspoređivanja.

\textbf{Primjer 1.}\footnote{Preuzet iz \citep{cupic2013prirodom}}
Zadana je funkcija $g(x, y, z)$ nad domenom $[-300, 500] \times [-300, 500] \times [-300, 500] \subset
\mathbb{R} \times \mathbb{R} \times \mathbb{R}$. Pronaći točku $(x, y, z)$ za koju funkcija $g$ poprima maksimalnu vrijednost.

\textbf{Primjer 2.} Satničaru su na raspolaganju popis kolegija koji se predaju, popis studenata i njihov izbor kolegija, popis slobodnih dvorana i termina,
željeni tjedni broj predavanja za svaki od kolegija te popis nastavnika koji predaju određene kolegije. Satničar treba zadovoljiti
sljedeće uvjete:
  \begin{itemize}
    \item svi studenti imaju zakazana sva predavanja i mogu ih slušati bez kolizija,
    \item niti jedan nastavnik ne drži više predavanja istovremeno,
    \item niti ujednu dvoranu ne smije biti smješteno više studenata nego što je kapacitet dvorane te
    \item niti ujednu prostoriju ne smiju biti smještena dva predavanja istovremeno.
  \end{itemize}
Također, bilo bi poželjno kada bi satničar osigurao da:
\begin{itemize}
  \item student u danu ima barem dva predavanja ili niti jedno,
  \item student ima minimalan broj rupa u danu,
  \item nastavnik ima minimalan broj rupa u danu te
  \item nastavnik ima minimalan broj promjena dvorana u danu.
\end{itemize}

\textbf{Primjer 3.}
Primjer u nastavku je pojednostavljen i prilagođen organizaciji međuispita na Fakultetu elektrotehnike i računarstva.
Prilikom izrade ispita dostupni su podaci o predmetima za koje treba održati ispit, podaci o slobodnim terminima te
podaci o studentima i ispitima kojima oni mogu pristupiti. Potrebno je izraditi raspored međuispita tako da niti jedan
student ne piše istovremeno dva ispita, da svaki student može pristupiti svakom svojem ispitu
te tako da se niti u jednoj dvorani ne pišu istovremeno dva ispita. Bilo bi poželjno
da student ima što ravnomjernije raspoređen broj slobodnih dana između ispita.

Na prethodnim primjerima se može primijetiti da se neki od uvjeta moraju ispuniti, dok su neka samo poželjna. To su tvrda
(engl. \textit{hard}) i meka (engl. \textit{soft}) ograničenja (engl. \textit{constraints}). Tvrda ograničenja moraju biti ispunjena kako bi rješenje bilo prihvatljivo (npr. u primjeru 2 ne može konačno rješenje biti ono u kojem nastavnik istovremeno predaje u dva termina). S druge strane, meka ograničenja nisu obavezna, ali što su ona ispunjenija, to je rješenje bolje.

Kako je u početku poglavlja ustanovljeno da se ovakvi problemi ne mogu rješavati tehnikom grube sile (engl. \textit{brute force}), postavlja
se pitanje na koje se načine u realnom vremenu može pronaći dovoljno dobro rješenje. Neki od optimizacijskih algoritama korišteni
za rješavanje problema raspoređivanja su navedeni u nastavku.

\section{Optimizacijski algoritmi}
U ovom poglavlju su navedena samo dva primjera algoritama koji se mogu primijeniti na probleme raspoređivanja. Konstruktivni optimizacijski
algoritam je detaljno opisan u narednim poglavljima, a postoji još mnoštvo drugih algoritama koji se mogu koristiti (algoritam roja
čestica, algoritmi umjetnih imunoloških sustava, genetski algoritmi itd.). Svaki od algoritama ima svoje prednosti i nedostatke te je
prikladniji za određenu specijalizaciju problema, dok za drugu vrstu problema daje slabije rezultate. Ova tvrdnja je poznata kao
\emph{no-free-lunch} teorem kojeg su Wolpert i Macready dokazali u svojim radovima, a u originalu glasi:

\begin{framed}
\emph{All algorithms that search for an extremum of a cost function perform exactly the same, according to any performance measure,
when averaged over all possible cost functions. In particular, if algorithm A outperforms algorithm B on some cost functions, then
loosely speaking there must exist exactly as many other functions where B outperforms A.}
\footnote{preuzeto s http://java.zemris.fer.hr/nastava/ui/evo/evo-20160608.pdf}
\end{framed}



\subsection{Mađarski algoritam}
Algoritam je razvio i objavio Harold Kuhn 1955. godine, a nadjenuo mu je ime \textit{mađarski} jer se algoritam velikom mjerom oslanja
na rad dvaju mađarskih matematičara Dénes Kőnig i Jenő Egerváry.
Algoritam je namijenjen raspoređivanju $n$ poslova na $n$ radnika pri čemu jedan radnik može obavljati samo jedan posao. Dakako,
problem bi se mogao preslikati na prethodno naveden primjer 1. ili na raspoređivanje studenata u kojem je svakom studentu pridružen
različit termin.

Vremenska složenost ovog algoritma je $\mathcal{O}(n^3$), a algoritam koristi sljedeći teorem:
\emph{Ako svakom elementu bilo kojeg retka ili stupca matrice kazne dodamo ili oduzmemo neki broj, tada je optimalno raspoređivanje za rezultantnu matricu također optimalno i za prvotnu matricu.} Pritom se matricom kazne smatra matrica čiji redci predstavljaju radnike, stupci predstavljaju poslove, a vrijednost matrice na mjestu $C(i, j)$ predstavlja cijenu dodjeljivanja radniku $i$ posao $j$.
Koraci algoritma slijede.
\begin{enumerate}
  \item Za svaki redak matrice, pronađi najmanji element i oduzmi ga od svakog elementa u njegovom retku.
  \item Ponovi korak 1. za svaki stupac.
  \item Prekrij sve nule u matrici koristeći minimalan broj horizontalnih i vertikalnih linija.
  \item Test optimalnosti: ako je minimalan broj linija potrebnih da se prekriju sve nule u matrici jednak $n$, tada je optimalno rješenje moguće
  i završavamo s izvođenjem algoritma. Ako je broj linija manji on $n$, tada optimalno rješenje nije pronađeno te nastavljamo na korak 5.
  \item Pronađi najmanji element matrice koji nije prekriven niti jednom linijom. Oduzmi taj element od svakog neprekrivenog
  retka i potom ga dodaj svakom prekrivenom stupcu. Vrati se na korak 3.
\end{enumerate}


Pogledajmo to sada na primjeru raspoređivanja poslova utovara robe, transporta robe te istovara robe među radnicima Petrom, Ivanom i Markom.
Neka je cijena pridjeljivanja poslova između radnika određena sljedećom matricom:
$$
\begin{bmatrix}
  \centering
  25 & 40 & 35 \\
  40 & 60 & 35 \\
  20 & 40 & 25
\end{bmatrix}.
$$
\begin{enumerate}
  \item Oduzmi najmanju vrijednost svakog retka.
  $$
  \begin{bmatrix}
    \centering
    0 & 15 & 10 \\
    5 & 25 & 0  \\
    0 & 20 & 5
  \end{bmatrix}.
  $$
  \item Prekrij sve nule minimalnim brojem linija.
  \[
    \begin{pspicture}
    \begin{bmatrix}
      \rnode{A}{0} & 0  & \rnode{B}{10} \\
      \rnode{C}{5} & 25 & \rnode{D}{0}  \\
      \rnode{E}{0} & 20 & 5
    \end{bmatrix}

    \psset{nodesep=-1.5ex, linewidth=0.4pt}
    \ncline{A}{B}\ncline[nodesep=-2ex]{C}{D}
    \ncline[nodesep=-2ex]{A}{E}
    \end{pspicture}
    \]
  \item S obzirom na to da je broj linija potrebnih za prekrivanje svih nula jednak $3$ optimalno rješenje je pronađeno.
\end{enumerate}
Poslove treba raspodijeliti tako da Petar radi transport robe, Ivan istovar, a Marko utovar. Cijena takvog raspoređivanja je 95.

\subsection{Algoritam kolonije mrava}
Ovaj algoritam je inspiriran procesom kojim mravi pronalaze najkraći put između mravinjaka i hrane. Mravi se prilikom potrage za hranom ne
služe svojim osjetilom vida, nego osjetilom feromona. Fermoni su kemijski tragovi koje mravi ostavljaju za sobom krećući se od
mravinjaka do hrane i povratno. Intenzitet mirisa fermona slabi s vremenom ako tim putem ne prolaze mravi. Kako mravi na ovaj način pronalaze
najkraći put između hrane i mravinjaka, intuitivno je jasno da je ovaj algoritam prikladan za pretraživanje grafova. Osim za pretraživanje grafova, algoritam kolonije mrava je uspješno primjenjivan na probleme izrade rasporeda
\footnote{Na primjer \url{https://www.researchgate.net/publication/268047044_Evolucijsko_racunanje_i_problem_izrade_rasporeda}}
te je u velikoj mjeri sličan konstruktivnom optimizacijskom algoritmu koji je tema ovog rada (fus nota: detaljnija usporedba algoritama je dana u narednim poglavljima).
Pseudo kod algoritma je:
\footnote{ Preuzeto s \url{https://www.researchgate.net/publication/268047044_Evolucijsko_racunanje_i_problem_izrade_rasporeda}}

$$
ponavljaj dok nije kraj \\
  ponovi za svakog mrava \\
    stvori rješenje \\
    vrednuj rješenje \\
  kraj ponovi \\
  ispari feromonske tragove \\
  ponovi za sve mrave \\
      ažuriraj feromonske tragove \\
  kraj ponovi \\
kraj ponavljanja \\
$$

Rješenje za svakog mrava se gradi tako da se odabire brid po brid kojima će mrav prolaziti (parovi bridova naravno moraju imati jednu
zajedničku točku, odnosno mora se moći nakon prvog brida prijeći na drugi brid itd.). Odabir kojim bridom će mrav poći iz trenutnog čvora
se određuje slučajnim proporcionalnim pravilom (engl. \textit{random proportional rule}):
\[
  p^k_ij =
  \begin{cases}
    \frac{\tau^\alpha_{ij}\cdot\eta^\beta_{ij}}{\sum_{l \in N^i_k}\tau^\alpha_{il}\cdot\eta^\beta_{il} } & \text{ako $j \in N^i_k$} \\
    0 & \text{ako} j \notin N^i_k
  \end{cases}
\]

pri čemu su $\alpha$ i $\beta$ konstante, $\tau$ je intenzitet fermona na bridu, a $\eta$ je heuristička informacija koliko je povoljno krenuti bridom. $N^i_k$ predstavlja sve bridove kojima je početni čvor trenutni čvor u kojem se mrav nalazi. Prije prve iteracije, sve vrijednosti tao se postavljaju na vrijednost koja je nešto veća od očekivane vrijednosti koju će mravi ostavljati u svakoj iteraciji. Za izračun se koristi formula:
$$
\tau_0 = \frac{m}{C^{mn}}
$$
pri čemu je $m$ broj mrava, a $C^{mn}$ je procjena najkraćeg puta dobivena nekim jednostavnijim algoritmom.

Isparavanje fermonskih tragova se vrši tako da se trenutna vrijednost pomnoži s konstantnim koeficijentom prema izrazu:
$$
\tau_{ij} \leftarrow \tau_{ij} \cdot (1 - \rho)
$$

Mravi ažuriraju feromonske tragove proporcionalno dobroti rješenja koje su izgradili prema izrazu:
$$
\tau_{ij} \leftarrow \tau_{ij} + \sum^m_{k=1} \Delta \tau^k_{ij}
$$
pri čemu je:
$$
\Delta \tau^k_{ij} =
\begin{cases}
  \frac{1}{C^k} & \text{ako je $i$-$j$ na stazi mrava} \\
  0 & \text{ako nije na stazi}
\end{cases}
$$

\chapter{Opis algoritma}
Konstruktivni optimizacijski algoritmi su široko korišteni algoritmi za heurističku optimizaciju. Inačica konstruktivnog optimizacijskog algoritma koji je korišten u ovom radu se temelji na radu \citep{zijun2014asymptotic}.

\section{Opći matematički model algoritma}
Promatramo problem s konačnim skupom izvodljivih rješenja S i funkcijom kazne f : S → R. Neka je skup S* skup optimalnih rješenja te isključimo trivijalna rješenja,
odnosno pretpostavim da |S| > 1 i da S∗ ≠ S. Neka se svako rješenje iz skupa S može zapisati kao konačan niz simbola s = (s1,...,sL) iz skupa abecede A : =
{a1,..., aK}. L je fiksna duljina rješenja. Model je generaliziran funkcijom izvodljivosti Ci(y, a) koja dodjeljuje težinu svakom a ∈ A za svako moguće parcijalno
rješenje y duljine i. Prema tome, ako je Ci(y, a) = 0, parcijalno rješenje y se ne može nastaviti tako da se na njega nadoda znak a. Što je vrijednost funkcije Ci(y, a) veća,
toliko je poželjnije da se niz nastavi znakom _a_ pohlepno (engl. greedy) gledano. Pretpostavlja se da su vrijednosti funkcije normirane. Model gradi rješenja korak po korak
dodavajući nove simbole na desni kraj niza sve dok rješenje nije potpuno. Formalnije rečeno, definiramo skup Ri izvodljivih parcijalnih rješenja rekurzivno kako slijedi:
neka _dijamant_ pretstavlja prazan string. Pretpostavljamo da je dano:
C0(_dijamant_, a) :A → [0, 1], Suma C0(_dijamant_, a) = 1 (za svaki a elemnt A)
što pretstavlja poželjnost i izvodljivost znaka _a_ na prvom mjestu rješenja. Nadalje definiramo:
R1 : = {a ∈ A | C0(, a) > 0}
Kao skup izvodljivih rješenja duljine 1. Pretpostavimo da je definiran skup Ri za neki i  ∈ {0,..., L − 1} i da je dano:
Ci(y, ·) :A → [0, 1], Suma-za-svaki-aEa(Ci(y, a) = 1) za svaki y ∈ Ri.
Neka (y, a) označava konkateniranje simabola a ∈ A na desni kraj parcijalnog rješenja y. Definiramo:
Ri+1 : = { (y, a) | y ∈ Ri, a ∈ A, Ci(y, a) > 0 }
i neka je S := RL. Za svaki y ∈ Ri, i ∈ {0,..., L − 1}, neka je
Ci(y) : = {a ∈ A | Ci(y, a) > 0}
bude potpora Ci(y, ·). -- We use the abbreviation I : = {0,..., L − 1} in the sequel. --

\chapter{Zaključak}
Zaključak.

\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}
Sažetak na hrvatskom jeziku.

\kljucnerijeci{Ključne riječi, odvojene zarezima.}
\end{sazetak}

% TODO: Navedite naslov na engleskom jeziku.
\engtitle{Title}
\begin{abstract}
Abstract.

\keywords{Keywords.}
\end{abstract}

\end{document}
